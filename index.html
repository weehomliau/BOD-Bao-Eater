<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Baozi Planet 3D</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; font-family: 'Courier New', Courier, monospace; }
        #score-board {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 24px;
            font-weight: bold;
            z-index: 10;
            text-shadow: 2px 2px #000;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.7);
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="score-board">Baozi Eaten: 0</div>
    <div id="controls">Use Arrow Keys or WASD to Move</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- 1. SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x202030);
        scene.fog = new THREE.Fog(0x202030, 20, 60);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // --- 2. THE TINY PLANET ---
        const planetRadius = 15;
        const planetGeometry = new THREE.SphereGeometry(planetRadius, 64, 64);
        const planetMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x445566, 
            roughness: 0.8,
            flatShading: true
        });
        const planet = new THREE.Mesh(planetGeometry, planetMaterial);
        planet.receiveShadow = true;
        scene.add(planet);

        // Grid helper for "Tron/Cyber" vibe
        const wireframe = new THREE.WireframeGeometry(planetGeometry);
        const line = new THREE.LineSegments(wireframe);
        line.material.depthTest = false;
        line.material.opacity = 0.15;
        line.material.transparent = true;
        line.material.color = new THREE.Color(0x00ffff);
        scene.add(line);

        // --- 3. THE PLAYER (BAOZI) ---
        const playerGroup = new THREE.Group();
        scene.add(playerGroup);

        // Bun Body
        const bunGeo = new THREE.SphereGeometry(0.8, 32, 32);
        // Flatten bottom slightly
        bunGeo.applyMatrix4(new THREE.Matrix4().makeScale(1, 0.75, 1)); 
        const bunMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
        const bun = new THREE.Mesh(bunGeo, bunMat);
        bun.position.y = 0.4;
        bun.castShadow = true;
        playerGroup.add(bun);

        // The Red Dot (Char Siu Bao style)
        const dotGeo = new THREE.CylinderGeometry(0.15, 0.15, 0.1, 16);
        const dotMat = new THREE.MeshStandardMaterial({ color: 0xff3333 });
        const dot = new THREE.Mesh(dotGeo, dotMat);
        dot.position.y = 1.05; // Sit on top
        playerGroup.add(dot);

        // Initial Position (Top of planet)
        playerGroup.position.set(0, planetRadius, 0);

        // --- 4. COLLECTIBLES (DOTS) ---
        const dots = [];
        const dotCount = 40;
        const dotGeoGlobal = new THREE.SphereGeometry(0.3, 8, 8);
        const dotMatGlobal = new THREE.MeshStandardMaterial({ color: 0xffd700, emissive: 0xaa6600 });

        function createDots() {
            for(let i=0; i<dotCount; i++) {
                const mesh = new THREE.Mesh(dotGeoGlobal, dotMatGlobal);
                
                // Random point on sphere surface
                const phi = Math.acos( -1 + ( 2 * i ) / dotCount );
                const theta = Math.sqrt( dotCount * Math.PI ) * phi;

                mesh.position.setFromSphericalCoords(planetRadius + 0.5, phi, theta);
                
                // Align to planet center
                mesh.lookAt(0,0,0);
                
                scene.add(mesh);
                dots.push({ mesh: mesh, active: true });
            }
        }
        createDots();

        // --- 5. GHOSTS (The "Steamers") ---
        const ghosts = [];
        const ghostCount = 3;
        
        function createGhosts() {
            const ghostGeo = new THREE.CapsuleGeometry(0.6, 1, 4, 8);
            const ghostMat = new THREE.MeshStandardMaterial({ color: 0xff00ff, transparent: true, opacity: 0.9 });
            
            for(let i=0; i<ghostCount; i++) {
                const g = new THREE.Group();
                const mesh = new THREE.Mesh(ghostGeo, ghostMat);
                mesh.position.y = 0.8;
                mesh.castShadow = true;
                g.add(mesh);
                
                // Spawn randomly
                const v = new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize().multiplyScalar(planetRadius);
                g.position.copy(v);
                
                scene.add(g);
                ghosts.push({ group: g, speed: 0.03 + (Math.random() * 0.02) });
            }
        }
        createGhosts();

        // --- 6. LIGHTING ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(50, 100, 50);
        dirLight.castShadow = true;
        dirLight.shadow.camera.top = 20;
        dirLight.shadow.camera.bottom = -20;
        dirLight.shadow.camera.left = -20;
        dirLight.shadow.camera.right = 20;
        scene.add(dirLight);

        // --- 7. GAME LOGIC & PHYSICS ---
        let score = 0;
        const scoreEl = document.getElementById('score-board');
        const keys = { w:false, a:false, s:false, d:false };

        window.addEventListener('keydown', (e) => {
            const k = e.key.toLowerCase();
            if(keys.hasOwnProperty(k) || k.startsWith('arrow')) {
                if(k === 'w' || k === 'arrowup') keys.w = true;
                if(k === 's' || k === 'arrowdown') keys.s = true;
                if(k === 'a' || k === 'arrowleft') keys.a = true;
                if(k === 'd' || k === 'arrowright') keys.d = true;
            }
        });

        window.addEventListener('keyup', (e) => {
            const k = e.key.toLowerCase();
            if(keys.hasOwnProperty(k) || k.startsWith('arrow')) {
                if(k === 'w' || k === 'arrowup') keys.w = false;
                if(k === 's' || k === 'arrowdown') keys.s = false;
                if(k === 'a' || k === 'arrowleft') keys.a = false;
                if(k === 'd' || k === 'arrowright') keys.d = false;
            }
        });

        // Helper: Align object to sphere surface
        function alignToSurface(obj, radius) {
            // 1. Get current position direction from center
            const up = obj.position.clone().normalize();
            
            // 2. Set position exactly on radius (prevents drifting off into space)
            obj.position.copy(up.multiplyScalar(radius));
            
            // 3. Rotate object so its Y-axis matches the "Up" vector (normal)
            const quaternion = new THREE.Quaternion();
            quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), up);
            obj.quaternion.copy(quaternion);
        }

        function animate() {
            requestAnimationFrame(animate);

            // --- PLAYER MOVEMENT ---
            const speed = 0.15;
            const moveDir = new THREE.Vector3(0, 0, 0);

            // Calculate local movement direction based on camera vs player
            if (keys.w) moveDir.z -= 1;
            if (keys.s) moveDir.z += 1;
            if (keys.a) moveDir.x -= 1;
            if (keys.d) moveDir.x += 1;

            if (moveDir.length() > 0) {
                moveDir.normalize().multiplyScalar(speed);
                
                // We need to move the player tangentially to the sphere.
                // Current player Up vector
                const up = playerGroup.position.clone().normalize();
                
                // Simple approach: Move in 3D space, then snap back to sphere
                // Get Camera's basis to determine "Forward" relative to view
                const camForward = new THREE.Vector3(); 
                camera.getWorldDirection(camForward);
                
                // Project camera forward onto the plane defined by player's Up vector
                // formula: v_proj = v - (v . n) * n
                camForward.sub(up.clone().multiplyScalar(camForward.dot(up))).normalize();
                
                const camRight = new THREE.Vector3().crossVectors(camForward, up).normalize(); // Note: Cross order matters
                
                // Calculate actual move vector in world space
                const globalMove = new THREE.Vector3()
                    .addScaledVector(camForward, -moveDir.z)
                    .addScaledVector(camRight, moveDir.x);

                playerGroup.position.add(globalMove);
                
                // Rotate the Baozi mesh inside the group to face movement direction
                if (moveDir.lengthSq() > 0) {
                   // Calculate angle for visual mesh
                   // This is complex on a sphere, simplifying by just rotating the group's child later if needed
                   // For now, the 'Red Dot' orientation acts as the head.
                }
            }

            // Snap Player to Sphere Surface
            alignToSurface(playerGroup, planetRadius);

            // --- CAMERA FOLLOW ---
            // Calculate ideal camera position: behind player and slightly up (relative to sphere normal)
            const playerPos = playerGroup.position.clone();
            const playerUp = playerPos.clone().normalize();
            
            // Offset: Go "up" (away from planet) and "back" (opposite of facing? Hard to define "facing" without velocity)
            // Let's make a generic third person orbit that looks at the planet center but focuses on player
            const cameraOffsetHeight = playerUp.clone().multiplyScalar(10); 
            const cameraOffsetBack = new THREE.Vector3(0,0,10).applyQuaternion(playerGroup.quaternion); // Naive back
            
            // Smoother Camera Logic:
            // Just position camera "above" the player along the radius
            const camDist = 25;
            const idealCamPos = playerPos.clone().normalize().multiplyScalar(camDist);
            
            // To make it playable, we usually tilt the camera back a bit.
            // Let's cheat: Put camera further out and look at player.
            camera.position.lerp(idealCamPos, 0.1);
            camera.lookAt(playerPos);
            // Tilt up slightly to see horizon
            camera.translateY(3);


            // --- COLLISION LOGIC ---
            
            // 1. Dots
            dots.forEach(dot => {
                if (dot.active) {
                    const dist = playerGroup.position.distanceTo(dot.mesh.position);
                    if (dist < 1.2) {
                        dot.active = false;
                        dot.mesh.visible = false;
                        score++;
                        scoreEl.innerText = "Baozi Eaten: " + score;
                        
                        // "Munch" effect
                        bun.scale.set(1.2, 0.8, 1.2);
                        setTimeout(() => bun.scale.set(1, 0.75, 1), 100);
                    }
                }
            });

            // 2. Ghosts (Simple Chasing AI)
            ghosts.forEach(ghost => {
                const gGroup = ghost.group;
                
                // Move towards player
                const direction = new THREE.Vector3().subVectors(playerGroup.position, gGroup.position).normalize();
                gGroup.position.add(direction.multiplyScalar(ghost.speed));
                
                // Snap ghost to surface
                alignToSurface(gGroup, planetRadius);
                
                // Hit check
                if (playerGroup.position.distanceTo(gGroup.position) < 1.5) {
                    // Game Over visual (turn red)
                    bunMat.color.setHex(0xff0000);
                    scoreEl.innerText = "GAME OVER! Score: " + score;
                    scoreEl.style.color = "red";
                }
            });

            // Animation for dots (spin)
            dots.forEach(d => {
                if(d.active) d.mesh.rotation.y += 0.05;
            });

            renderer.render(scene, camera);
        }

        animate();

        // Handle Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
