<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>åƒåŒ…å­å¤§æŒ‘æˆ˜ - æ™ºèƒ½è¿½è¸ªç‰ˆ</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            width: 100vw;
            height: 100vh;
        }

        #game-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
        }

        /* è§†é¢‘å±‚ï¼šä½¿ç”¨ cover ä¿æŒæ¯”ä¾‹å¡«å…… */
        video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
            object-fit: cover;
            z-index: 1;
        }

        /* ç”»å¸ƒå±‚ */
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
            z-index: 2;
        }

        /* UIå±‚ */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            padding: 20px;
            align-items: center;
        }

        .hud-group {
            display: flex;
            gap: 15px;
        }

        #score-board, #timer-board {
            color: #ffcc00;
            font-size: 28px;
            font-weight: 900;
            text-shadow: 3px 3px 0 #000;
            background: rgba(0,0,0,0.6);
            padding: 8px 15px;
            border-radius: 20px;
            min-width: 100px;
            text-align: center;
        }
        
        #timer-board {
            color: #00ccff;
        }

        #status-indicator {
            color: white;
            font-size: 20px;
            font-weight: bold;
            background: rgba(0,0,0,0.6);
            padding: 8px 15px;
            border-radius: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: red;
            transition: background-color 0.2s;
        }

        #overlay-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            pointer-events: auto;
            text-align: center;
        }

        .hidden { display: none !important; }

        button {
            background: #ff4757;
            border: none;
            color: white;
            padding: 15px 32px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 20px;
            margin: 10px 2px;
            cursor: pointer;
            border-radius: 50px;
            font-weight: bold;
            transition: transform 0.1s;
        }
        button:active { transform: scale(0.95); }

        .mouth-active { background-color: #2ed573 !important; box-shadow: 0 0 10px #2ed573; }
        
        /* è°ƒè¯•ä¿¡æ¯ */
        #debug-info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: lime;
            font-size: 14px;
            background: rgba(0,0,0,0.5);
            padding: 5px;
            pointer-events: none;
        }

        @media (max-width: 600px) {
            .hud-top {
                flex-direction: column;
                gap: 10px;
                align-items: flex-start;
            }
            #score-board, #timer-board {
                font-size: 20px;
                min-width: 60px;
            }
        }
    </style>
</head>
<body>

<div id="game-wrapper">
    <video id="video" playsinline></video>
    <canvas id="output"></canvas>
    
    <div id="ui-layer">
        <div class="hud-top">
            <div class="hud-group">
                <div id="score-board">å¾—åˆ†: 0</div>
                <div id="timer-board">æ—¶é—´: 90</div>
            </div>
            <div id="status-indicator">
                <div id="mouth-dot" class="status-dot"></div>
                <span id="mouth-text">è¯·å¼ å¤§å˜´å·´</span>
            </div>
        </div>
        <!-- è°ƒè¯•æ˜¾ç¤º -->
        <div id="debug-info">ç­‰å¾…é¢éƒ¨æ£€æµ‹...</div>
    </div>

    <!-- é®ç½©å±‚ -->
    <div id="overlay-screen">
        <h1 id="overlay-title">åƒåŒ…å­å¤§ä½œæˆ˜ (æ™ºèƒ½è¿½è¸ªç‰ˆ)</h1>
        <p id="overlay-desc">æ­£åœ¨åˆå§‹åŒ– AI...</p>
        <button id="start-btn" class="hidden">å¼€å§‹æ¸¸æˆ</button>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/face-landmarks-detection"></script>

<script>
    const CONFIG = {
        // é˜ˆå€¼è®¾å®šï¼šå˜´å·´å¼ å¼€åº¦ (é«˜åº¦/å®½åº¦) å¤§äºæ­¤å€¼å³åˆ¤å®šä¸ºå¼ å˜´
        // 0.05 æ˜¯ä¸€ä¸ªéå¸¸çµæ•çš„å€¼ï¼Œç¨å¾®å¼ å¼€ä¸€ç‚¹å°±èƒ½è§¦å‘
        mouthRatioThreshold: 0.05, 
        baseSpeed: 6.0,         // é€Ÿåº¦è°ƒå› 6.0
        initialSpawnRate: 1200, // é¢‘ç‡ç¨å¾®è°ƒå›é€‚ä¸­ï¼Œé˜²æ­¢å †ç§¯è¿‡å¤š
        minSpawnRate: 250,      // æœ€å¿«é¢‘ç‡
        gameDuration: 90        
    };

    const AudioSys = {
        ctx: null,
        init: function() {
            window.AudioContext = window.AudioContext || window.webkitAudioContext;
            this.ctx = new AudioContext();
        },
        playEat: function() {
            if (!this.ctx) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(600, this.ctx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.1);
            gain.gain.setValueAtTime(0.5, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);
            osc.connect(gain);
            gain.connect(this.ctx.destination);
            osc.start();
            osc.stop(this.ctx.currentTime + 0.15);
        },
        playExplosion: function() {
            if (!this.ctx) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(100, this.ctx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(10, this.ctx.currentTime + 0.5);
            gain.gain.setValueAtTime(1, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);
            osc.connect(gain);
            gain.connect(this.ctx.destination);
            osc.start();
            osc.stop(this.ctx.currentTime + 0.5);
        },
        playTimeUp: function() {
            if (!this.ctx) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = 'square';
            osc.frequency.setValueAtTime(400, this.ctx.currentTime);
            osc.frequency.linearRampToValueAtTime(300, this.ctx.currentTime + 0.3);
            gain.gain.setValueAtTime(0.5, this.ctx.currentTime);
            gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.3);
            osc.connect(gain);
            gain.connect(this.ctx.destination);
            osc.start();
            osc.stop(this.ctx.currentTime + 0.3);
        }
    };

    let detector, video, ctx, canvas;
    let isGameRunning = false;
    let score = 0;
    let items = []; 
    let lastSpawnTime = 0;
    let gameStartTime = 0; 
    let mouthData = { open: false, x: 0, y: 0 };
    // ç”¨äºå¯è§†åŒ–çš„å…³é”®ç‚¹
    let debugPoints = [];
    
    let screenW = window.innerWidth;
    let screenH = window.innerHeight;

    const scoreEl = document.getElementById('score-board');
    const timerEl = document.getElementById('timer-board');
    const mouthDotEl = document.getElementById('mouth-dot');
    const mouthTextEl = document.getElementById('mouth-text');
    const overlayEl = document.getElementById('overlay-screen');
    const overlayTitle = document.getElementById('overlay-title');
    const overlayDesc = document.getElementById('overlay-desc');
    const startBtn = document.getElementById('start-btn');
    const debugEl = document.getElementById('debug-info');

    async function main() {
        video = document.getElementById('video');
        canvas = document.getElementById('output');
        ctx = canvas.getContext('2d');

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        try {
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { facingMode: 'user' },
                audio: false
            });
            video.srcObject = stream;
            await new Promise(resolve => video.onloadedmetadata = resolve);
            video.play();
        } catch (e) {
            overlayDesc.innerHTML = "æ— æ³•æ‰“å¼€æ‘„åƒå¤´ï¼Œè¯·ç¡®ä¿å…è®¸æƒé™ã€‚";
            return;
        }

        try {
            overlayDesc.innerText = "åŠ è½½ AI æ¨¡å‹ä¸­...";
            await tf.ready();
            
            detector = await faceLandmarksDetection.createDetector(
                faceLandmarksDetection.SupportedModels.MediaPipeFaceMesh,
                { runtime: 'tfjs', maxFaces: 1 }
            );
            
            overlayDesc.innerText = "å‡†å¤‡å°±ç»ªï¼";
            startBtn.classList.remove('hidden');
            startBtn.addEventListener('click', startGame);
            
            detectFaceLoop();
        } catch (e) {
            overlayDesc.innerText = "æ¨¡å‹åŠ è½½å¤±è´¥ï¼Œè¯·åˆ·æ–°é‡è¯•ã€‚";
            console.error(e);
        }
    }

    function resizeCanvas() {
        screenW = window.innerWidth;
        screenH = window.innerHeight;
        canvas.width = screenW;
        canvas.height = screenH;
    }

    async function detectFaceLoop() {
        if (detector && !video.paused && !video.ended) {
            try {
                const faces = await detector.estimateFaces(video);
                
                // é‡ç½®è°ƒè¯•ç‚¹
                debugPoints = [];

                if (faces.length > 0) {
                    const kp = faces[0].keypoints;
                    
                    // å…³é”®ç‚¹ï¼š
                    // 13: ä¸Šå”‡, 14: ä¸‹å”‡
                    // 61: å·¦å˜´è§’, 291: å³å˜´è§’
                    const up = kp[13];
                    const low = kp[14];
                    const left = kp[61];
                    const right = kp[291];

                    if (up && low && left && right) {
                        // 1. åæ ‡æ˜ å°„ (é€‚é… object-fit: cover)
                        const videoW = video.videoWidth;
                        const videoH = video.videoHeight;
                        const screenRatio = screenW / screenH;
                        const videoRatio = videoW / videoH;

                        let scale = 1;
                        let offsetX = 0;
                        let offsetY = 0;

                        if (screenRatio > videoRatio) {
                            scale = screenW / videoW;
                            const renderedHeight = videoH * scale;
                            offsetY = (renderedHeight - screenH) / 2;
                        } else {
                            scale = screenH / videoH;
                            const renderedWidth = videoW * scale;
                            offsetX = (renderedWidth - screenW) / 2;
                        }

                        // è¾…åŠ©å‡½æ•°ï¼šå°†è§†é¢‘åæ ‡è½¬ä¸ºå±å¹•åæ ‡
                        const toScreen = (pt) => ({
                            x: (pt.x * scale) - offsetX,
                            y: (pt.y * scale) - offsetY
                        });

                        const sUp = toScreen(up);
                        const sLow = toScreen(low);
                        const sLeft = toScreen(left);
                        const sRight = toScreen(right);

                        // ä¿å­˜è°ƒè¯•ç‚¹ä»¥ä¾›ç»˜åˆ¶
                        debugPoints = [sUp, sLow, sLeft, sRight];

                        mouthData.x = sUp.x; 
                        mouthData.y = (sUp.y + sLow.y) / 2;
                        
                        // 2. ä½¿ç”¨ã€æ¯”ä¾‹ã€‘åˆ¤å®šï¼Œè€Œä¸æ˜¯åƒç´ è·ç¦»
                        const mouthH = Math.hypot(sUp.x - sLow.x, sUp.y - sLow.y); // å˜´é«˜
                        const mouthW = Math.hypot(sLeft.x - sRight.x, sLeft.y - sRight.y); // å˜´å®½
                        
                        // é˜²æ­¢é™¤ä»¥0
                        const ratio = mouthH / (mouthW + 1);
                        
                        // åˆ¤å®š
                        mouthData.open = ratio > CONFIG.mouthRatioThreshold;
                        
                        // æ›´æ–°è°ƒè¯•ä¿¡æ¯
                        debugEl.innerText = `æ£€æµ‹ä¸­: å¼ å¼€åº¦ ${ratio.toFixed(2)} (é˜ˆå€¼: ${CONFIG.mouthRatioThreshold})`;
                        debugEl.style.color = mouthData.open ? "#2ed573" : "yellow";

                        if (mouthData.open) {
                            mouthDotEl.classList.add('mouth-active');
                            mouthTextEl.innerText = "å¼ å¼€äº†";
                            mouthTextEl.style.color = "#2ed573";
                        } else {
                            mouthDotEl.classList.remove('mouth-active');
                            mouthTextEl.innerText = "è¯·å¼ å˜´";
                            mouthTextEl.style.color = "white";
                        }
                    }
                } else {
                    debugEl.innerText = "æœªæ£€æµ‹åˆ°äººè„¸ - è¯·è°ƒæ•´å…‰çº¿æˆ–è·ç¦»";
                    debugEl.style.color = "red";
                }
            } catch (e) {
                console.error(e);
            }
        }
        requestAnimationFrame(detectFaceLoop);
    }

    class GameItem {
        constructor() {
            this.type = Math.random() < 0.2 ? 'bomb' : 'bun';
            
            // Xåæ ‡éšæœºï¼Œé™åˆ¶åœ¨å±å¹•å†…
            this.x = Math.random() * (screenW - 60) + 30;
            this.y = -50;
            this.size = 40;
            
            this.speed = Math.random() * 4 + CONFIG.baseSpeed + (score / 10);
            this.delete = false;
        }

        update() {
            this.y += this.speed;
            if (this.y > screenH + 50) this.delete = true;
        }

        draw(ctx) {
            ctx.beginPath();
            if (this.type === 'bun') {
                ctx.fillStyle = "#ffffff";
                ctx.arc(this.x, this.y, this.size/2, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = "#e0e0e0";
                ctx.lineWidth = 2;
                ctx.stroke();
                // è¤¶çš±
                ctx.beginPath();
                ctx.moveTo(this.x - 10, this.y - 10);
                ctx.lineTo(this.x + 10, this.y + 10);
                ctx.stroke();
            } else {
                ctx.fillStyle = "#333333";
                ctx.arc(this.x, this.y, this.size/2, 0, Math.PI * 2);
                ctx.fill();
                // çº¢è‰²ä¸­å¿ƒ
                ctx.fillStyle = "red";
                ctx.beginPath();
                ctx.arc(this.x, this.y, 8, 0, Math.PI * 2);
                ctx.fill();
                // å¹å·
                ctx.fillStyle = "white";
                ctx.font = "12px Arial";
                ctx.textAlign = "center";
                ctx.fillText("!", this.x, this.y + 4);
            }
        }
    }

    function startGame() {
        AudioSys.init();
        overlayEl.classList.add('hidden');
        isGameRunning = true;
        score = 0;
        items = [];
        scoreEl.innerText = "å¾—åˆ†: 0";
        timerEl.innerText = "æ—¶é—´: " + CONFIG.gameDuration;
        
        items.push(new GameItem()); 
        lastSpawnTime = 0;
        
        gameStartTime = performance.now();
        gameLoop(gameStartTime);
    }

    function gameOver(isTimeUp = false) {
        isGameRunning = false;
        
        if (isTimeUp) {
            AudioSys.playTimeUp();
            overlayTitle.innerText = "â° æ—¶é—´åˆ°ï¼";
        } else {
            AudioSys.playExplosion();
            overlayTitle.innerText = "ğŸ’¥ æ¸¸æˆç»“æŸ";
        }
        
        overlayDesc.innerText = `æœ€ç»ˆå¾—åˆ†: ${score}`;
        startBtn.innerText = "å†ç©ä¸€æ¬¡";
        overlayEl.classList.remove('hidden');
    }

    function gameLoop(timestamp) {
        // æ— è®ºæ¸¸æˆæ˜¯å¦è¿è¡Œï¼Œéƒ½ç»˜åˆ¶è°ƒè¯•ç‚¹ï¼Œæ–¹ä¾¿æ‰¾ä½ç½®
        if (debugPoints.length > 0) {
            // å¦‚æœæ¸¸æˆæ²¡è¿è¡Œï¼Œå…ˆæ¸…ç©ºä¸€ä¸‹ç”»å¸ƒ(é¿å…é‡å )ï¼Œå¦åˆ™æ¸¸æˆå¾ªç¯ä¼šæ¸…ç©º
            if (!isGameRunning) ctx.clearRect(0, 0, screenW, screenH);
            
            // ç»˜åˆ¶çº¢ç‚¹
            ctx.fillStyle = "red";
            for (let p of debugPoints) {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        if (!isGameRunning) {
            requestAnimationFrame(gameLoop);
            return;
        }

        // æ­£å¸¸æ¸¸æˆå¾ªç¯
        ctx.clearRect(0, 0, screenW, screenH);
        
        // é‡ç»˜çº¢ç‚¹ (åœ¨æ¸…ç©ºå)
        if (debugPoints.length > 0) {
            ctx.fillStyle = "red";
            for (let p of debugPoints) {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        const elapsed = (timestamp - gameStartTime) / 1000;
        const remaining = Math.max(0, Math.ceil(CONFIG.gameDuration - elapsed));
        
        timerEl.innerText = "æ—¶é—´: " + remaining;
        
        if (remaining <= 10) {
            timerEl.style.color = "#ff4757";
        } else {
            timerEl.style.color = "#00ccff";
        }

        if (remaining <= 0) {
            gameOver(true);
            return;
        }

        let currentSpawnRate = Math.max(
            CONFIG.minSpawnRate, 
            CONFIG.initialSpawnRate - (score * 10) 
        );

        if (!lastSpawnTime || timestamp - lastSpawnTime > currentSpawnRate) {
            items.push(new GameItem());
            
            if (score > 10 && Math.random() < 0.4) {
                items.push(new GameItem()); 
            }
            if (score > 30 && Math.random() < 0.4) {
                items.push(new GameItem()); 
            }

            lastSpawnTime = timestamp;
        }

        // ç»˜åˆ¶å˜´å·´çŠ¶æ€åœˆ
        if (mouthData.open) {
            ctx.strokeStyle = "#2ed573";
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(mouthData.x, mouthData.y, 30, 0, Math.PI * 2);
            ctx.stroke();
        }

        // æ›´æ–°ç‰©ä½“
        for (let i = items.length - 1; i >= 0; i--) {
            let item = items[i];
            item.update();
            item.draw(ctx);

            let dist = Math.sqrt((item.x - mouthData.x) ** 2 + (item.y - mouthData.y) ** 2);
            
            if (dist < 40 && mouthData.open) {
                if (item.type === 'bun') {
                    score++;
                    scoreEl.innerText = "å¾—åˆ†: " + score;
                    AudioSys.playEat();
                    item.delete = true;
                    // æ˜¾ç¤º +1
                    ctx.fillStyle = "yellow";
                    ctx.font = "bold 24px Arial";
                    ctx.fillText("+1", mouthData.x, mouthData.y - 40);
                } else {
                    gameOver(false);
                    return; 
                }
            }

            if (item.delete) {
                items.splice(i, 1);
            }
        }

        requestAnimationFrame(gameLoop);
    }

    main();
</script>
</body>
</html>
